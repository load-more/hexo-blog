---
title: 83 正则表达式
date: 2021-11-24 18:47:30
tags: [RegularExpression]
categories: Crawler
---

抽空重新学了一下爬虫，接触到了正则表达式提取数据，于是总结了一下正则表达式的一些使用方法。

<!-- more -->

## 集合：[]

集合用于**匹配单个字符**，只要满足集合内的条件就可以匹配成功。

### 范围

用 `-` 连接，表示某个范围内的字符可以匹配。

- `[0-9]`：匹配 0 到 9
- `[a-z]`：匹配 a 到 z
- `[A-Z]`：匹配 A 到 Z

> 注意：`-` 只有在集合内，也就是 `[]` 内，才表示范围，如果在集合之外，只表示匹配 `-` 字符而已。

### 非

集合内第一个字符为 `^`，表示只要不是 `^` 后的情况就可以匹配。

**注意，“^” 一定要放在集合内首位才表示 “非”，否则会认为匹配 “^” 字符。**

例如：

- `[^0-9\sa-z]` 表示如果不是 **数字** 或者 **空白字符** 或者 **小写字母**，就可以匹配；
- `[\s^0-9a-z]` 表示如果是 **空白字符** 或者 **^** 或者 **数字** 或者 **小写字母**，就可以匹配。

### 简写

在转移字符 `\` 后加特定的字符，表示某类范围的简写。

- `\d`：匹配数字 ，`[0-9]` 的简写
- `\D`：匹配非数字，`[^0-9]` 的简写
- `\w`：匹配字母、数字、下划线，`[A-Za-z0-9_]`的简写
- `\W`：匹配非字母、数字、下划线，`[^A-Za-z0-9_]` 的简写
- `\s`：匹配空白字符（空格、tab制表符、vertical tab纵向制表符、LF换行符、CR回车符），`[ \t\v\n\r]` 的简写
- `\S`：匹配非空白字符，`[^ \t\r]` 的简写

> 注意：这些简写既可以用于集合内，也可以用于集合外，比如 `[\d]` 和 `\d` 都可以用于匹配单个数字字符。像一些其它特殊字符，如 `.` 或 `+` 或 `{}` 只能用于集合外，在集合内使用这些特殊字符只表示匹配这些字符而已，没有特殊作用。

---

以上讨论的都是集合以及一些特殊字符的用法。

某些特殊字符只能作用于集合内，比如在集合内 `-` 表示范围，如果在集合外，它便只表示 `-` 字符而已，失去了特殊作用；

而某些特殊字符只能作用于集合外，比如 `. + * {} ?` 等字符，它们在集合外有各自特殊的作用，而在集合内仅表示字符本身而已；

另外一些特殊字符既可以作用于集合外，也可以作用于集合内。有些在集合内或集合外都是相同的作用，比如上面提到的一些简写字符：`\d \w \s` 等；而有些在集合内或集合外的作用各不相同，比如 `^`，它在集合内可表示非，在集合外表示以某个字符开头。

下面，我们就讨论在集合之外一个特殊字符的用法。



## 回车、换行

这里需要注意的是换行符和回车符虽然都不可见，但确是两个完全不同的概念。

换行和回车是两个完全不同的动作，它们源于以前的针式打印机，针式打印机要打印一篇文章，就需要依靠针头和纸张进行相对运动完成。当打印一行内容时，纸张静止，针头从左往右运动（按照人类的阅读习惯），当需要打印下一行时，这里就需要完成两个动作：1. 将针头向左移动到原点，2. 将纸张上移一行的距离。当然，这两个动作的顺序可以任意，之后就可以重新打印新的一行了。

回车（Carriage Return），类似于将针头移动到原点的动作，相对于将光标移动到行首，用 `\r` 表示；

换行（Line Feed），类似于将纸张上移的动作，相当于将光标下移一行，用 `\n` 表示。

所以当我们按下键盘的 `Enter` 键时，其实完成了两个动作：回车 + 换行。我们习惯于将 `Enter` 键称为 “回车键”，其实这是不准确的，严格来讲，应该叫 “回车换行键”。

但是在不同系统中，表示 “回车换行” 的字符可能不尽相同，例如：

- 在 Windows 系统中，用 `\n` 表示回车换行，`\r` 表示光标回到行首但不会另起一行，因此下一行的内容会覆盖前一行的内容，例如：

```python
print('aaaaaa\rbbb') # 打印：bbbaaa

print('aaaaaa\nbbb')
'''
打印：
aaaaaa
bbb
'''

print('aaaaaa\r\nbbb') # 作用和 \n 相同
'''
打印：
aaaaaa
bbb
'''
```

- 在 Mac 系统中，用 `\r` 表示回车换行（不会覆盖），`\n` 表示将光标下移一行；
- 在 Linux 或 Unix 系统中，用 `\r\n` 表示回车换行，更加严谨。



## 通配

### 点字符

在集合外，可以使用 `.` 表示除换行符(`\n`)和回车符(`\r`)之外的任意字符，等价于 `[^\n\r]`。

### 完全通配

虽然使用 `.` 可以匹配绝大部分字符，但是却不能匹配回车符和换行符，在某些情况下不能达到预期，例如：

```
/hello.*world/

hello fsdafadsf fsd
fsdafsdf
fsda
fds world
```

上面，我们想要匹配首尾是 hello 和 world 的文本，其中我们使用 `.` 表示任意字符，但结果却不能匹配到测试文本，因为测试文本是多行文本，包含了一些回车符或换行符。

想要匹配成功，就可以用到完全通配：

- `[\s\S]`
- `[\d\D]`
- `[\w\W]`

以上三种都可以匹配任意字符（包括回车符和换行符）。



## 锚定

锚定字符主要有以下四个：

- `^`：代表的就是字符串的开头
- `$`：代表的就是字符串的结尾

例如，这有一串字符：

```
<hello xxx
sfdsaf 
fsdf fsd >
```

假如现在要匹配 `<>` 里的内容（包含尖括号），就可以写出正则表达式：`/^<[\s\S]*>$/g`（因为有换行，所以用到完全通配`[\s\S]`）。其中 `^` 代表整段字符的开头，`$` 代表整段字符的结尾，开头和结尾之间满足 `<[\s\S]*>` 的要求即可匹配成功。

上述情况，`^` 和 `$` 针对的是整段字符的开头和结尾，假如我们需要让 `^` 和 `$` 表示每行字符的开头和结尾，这时我们就需要用到标识 `m` 了。例如使用 `/^<[\s\S]*>$/gm`，就可以进行每行匹配而不是整段匹配。

- `\b`：代表单词边界，比如空格、行尾、行首等。
- `\B`：代表非单词边界。

> 上面四种锚定字符通常是放在正则表达式的两端，因为它们代表的边界，例如：
>
> ```
> /^\w+$/g
> /\b\w+\b/g
> /\B\w+\B/g
> ```



## 重复：{}

### 范围

- `{m}`：重复 m 次；
- `{m,n}`：最少重复 m 次，最多重复 n 次；
- `{m,}`：最少重复 m 次，重复次数无上限。

*注意：逗号两边不能有空格。*

### 简写

- `?`：重复 0 次或 1 次，相当于 `{0,1}`；
- `*`：重复 0 次或多次，相当于 `{0,}`；
- `+`：重复 1 次或多次，相当于 `{1,}`。

> 注意，以上三个字符都是作用于前一个字符或分组，例如 `/ab*/g` ，其中 `*` 只作用于前一个字符 `b`，而不影响其它字符。或者 `/a(ae|ab|ad)+a/`，其中 `+` 只作用于前面的分组。

### 懒惰模式

在使用重复时，正则表达式默认开启的是贪婪模式，也就是会尽可能多的匹配字符。例如：

```
/ab+/g

abbbbbb
```

上面例子中，由于默认开启的是贪婪模式，所以会尽可能增加 `b` 的重复次数，导致匹配了所有的 `b`。

而当在重复后面加上 `?` 时，表示开启懒惰模式，这就会尽可能减少 `b` 的重复次数，由于是 `+`，最少重复 1 次，所以匹配了 `ab`。

> 注意，只有在重复时，才可能会使用到懒惰模式，所以 `?` 一般跟在重复的后面。比如：
>
> `/ab+?/g` 或者 `/ab*?/g` 或者 `/ab{3,6}?/g`



## 分组

### 捕获分组

当使用正则表达式匹配到结果时，有时需要提取其中的某些数据，例如匹配到个人信息后，提取其中出生日期。这时就可以用到捕获分组。

捕获分组用 `()` 表示，会将括号里面的字符分到一个组中并打上标记。之后，如果想要引用某个组的数据，就可以根据这个标记进行**数字引用**。例如：

```
<h>Demo<h>
```

假如现在要提取上面尖括号里面的内容，我们可以写出正则表达式：`/(<\w+>).*(<\w+>)/g`。但此时，无论两边尖括号里面的内容是否相同，都可以匹配成功。如果我们规定只能匹配两边内容相同的尖括号应该怎么办？

这时就可以使用到捕获分组的**数字引用**了。

我们可以这样写：`/(<\w+>).*(\1)/g`。这里的 `\1` 表示引用的是第一个分组里的内容，这就表示两边的内容要完全相同才能够匹配成功。同样，如果有多个分组的话，数字标记往后类推，注意分组的标记是从左到右依次递增的。

> 注意：数字引用只能作用于捕获分组，不能作用于非捕获分组。

### 非捕获分组

当我们想用到分组的一些特性，却又不想将数据提取出来，这时就可以用到非捕获分组。

格式：`(?:表达式)`。

例如，我们想利用分组里面的多选匹配字符，但又不想将数据提取出来：

```
/hello\s(?:Tom|Jack|Amy)/g

hello Tom
hello Jack
hello Amy
```

### 多选

在分组中可以使用 `|` 表示多选，类似于逻辑 “或”，用于匹配 `|` 前面的或后面的表达式。

它也可以在整个表达式中使用。会按顺序尝试匹配。



## 断言

### 正向先行断言

格式：`(?=表达式)`

指如果某个位置右侧的内容可以满足表达式就表示匹配成功，否则失败。

比如：`/\d+(?=px)/g`，这里断言位置是在 `\d+` 的后面，表示 `\d+` 右侧的内容必须满足表达式，也就是 `px`，才能匹配成功。所以，`10px` 可以匹配成功，`1p2x` 或者 `1ppx` 这些就不能匹配成功。

### 反向先行断言

格式：`(?!表达式)`

指如果某个位置右侧的内容不满足表达式就表示匹配成功。

### 正向后行断言

格式：`(?<=表达式)`

指如果某个位置左侧的内容满足表达式就表示匹配成功。

### 反向后行断言

格式：`(?<!表达式)`

指如果某个位置左侧的内容不满足表达式就表示匹配成功。



## 练习网站

- https://regexr-cn.com/
- https://codejiaonang.com/#/courses
