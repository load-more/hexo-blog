---
title: 80 V8引擎垃圾回收机制
date: 2021-09-18 09:25:11
tags: [JavaScript, GC]
categories: JavaScript
---

学习 V8 引擎下的垃圾回收机制。

<!-- more -->

## JavaScript 垃圾回收机制

### 垃圾回收策略

---

#### 引用计数

引用计数（Reference Counting），这是早期使用的一种垃圾回收算法。它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。目前很少使用这种算法了，因为它的问题很多。

工作原理：

- 当创建一个对象，且这个对象被一个变量引用时，那么这个对象的引用次数为 1；
- 如果这个对象又被另一个变量引用，那么引用次数加 1；
- 如果其中一个变量不再引用这个对象，那么引用次数减 1；
- 当这个对象的引用次数变为 0 的时候，说明没有变量在使用，所以垃圾回收器会在运行的时候清理掉引用次数为 0 的对象，释放空间。

例子如下：

```js
let a = new Object() // 此对象的引用次数为 1（a 引用）
let b = a 		    // 此对象的引用次数为 2（a, b 引用）
a = null  		    // 此对象的引用次数为 1（b 引用）
b = null 	 	    // 此对象的引用次数为 0（无引用）
...			        // GC 回收此对象
```

这种方式虽然方便，但会出现 `循环引用` 的问题，如下：

```js
function test() {
    let A = new Object() // x对象引用次数为 1（A 引用）
    let B = new Object() // y对象引用次数为 1（B 引用）
    
    A.obj = B // y对象引用次数为 2（B，obj）引用
    B.obj = A // x对象引用次数为 2（A，obj）引用
}
test() // A，B 变量销毁，两个对象引用次数各减 1
```

函数运行完毕后，虽然 A、B 变量会被销毁，但是由于存在循环引用，两个创建的对象引用次数仍为 1，所以这两个创建的对象不会被垃圾回收器回收。

这样，一旦这个函数被多次调用，就会导致内存中存在非常多的垃圾对象。



#### 标记清除

标记清除（Mark-Sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，目前为止的大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 `JavaScript引擎` 在运行垃圾回收的频率上有所差异。

此算法分为 `标记` 和 `清除` 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。

工作原理：

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0；
- 然后从各个根对象开始遍历，把不是垃圾的对象改成 1；
- 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间；
- 最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收。

标记清除算法有一个很大的缺点：在清除之后，剩余的对象内存位置并不是连续的，出现了 `内存碎片`，并且由于剩余空闲内存不是一整块，而是由不同大小内存组成的内存列表，这就会导致后续资源的内存分配出现一些问题。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-watermark.awebp)



#### 标记整理

而 **标记整理（Mark-Compact）算法** 就可以有效地解决这个问题。它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，使剩余内存变成一块连续的空间。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04b0a5a40084e0ba4550500c57f2270~tplv-k3u1fbpfcp-watermark.awebp)





### V8垃圾回收

---

#### V8内存结构

V8 引擎的内存结构主要由以下几个部分组成：

- `新生代(new space)`：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。
- `老生代(old space)`：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为`老生代指针区`和`老生代数据区`，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。
- `大对象区(large object space)`：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。
- `代码区(code space)`：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。
- `map区(map space)`：存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。

![](https://gitee.com/gainmore/imglib/raw/master/img/mem.png)

这里主要研究的是堆内存中的 `新生代空间` 和 `老生代空间`。

首先，新生代空间里面分两个完全相等的空间：`From` 和 `To`，而老生代空间里面的内存是连续的，不存在均分。

再者，新生代空间和老生代空间的内存和操作系统有关：

- 64 位系统：新生代空间为 64 MB，老生代空间为 1400 MB；
- 32 位系统：新生代空间为 32 MB，老生代空间为 700 MB；
- 最新版的 Node（V14）的内存为 2GB。

那么，为什么空间会设计成 1.4 GB？

这是因为 JS 代码一般处理一些比较轻量的任务，所以不需要十分大的内存空间，而且如果分配的空间过大，那么进行一次垃圾回收的时间也会随之增大，不利于性能优化。



#### 分代式垃圾回收

---

新生代和老生代采取了不同的算法：

- 新生代：`Scavenge算法`
- 老生代：`Mark-Sweep(标记清除算法)`  -->  `Mark-Compact(标记整理算法)`

##### 新生代

新生代采取的是 `Scavenge算法`。它是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，**大部分对象的生命周期较短，而且新生代空间较小**，在时间效率上表现可观，所以还是比较适合这种算法。

新生代垃圾回收过程：

- 新生代空间均分为 `From` 和 `To` 两部分，当任务执行时，会将对象分配到 `From` 空间上；
- 当任务执行完毕进行垃圾回收时，会给不活动的对象打上标记，然后将活动的对象复制到 `To` 空间上；
- 接下来将 `From` 空间清空，然后将 `From` 空间和 `To` 空间进行互换，如此往复。

---

##### 对象晋升

当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程称之为`晋升`。
对象晋升的条件主要有以下两个：

- 对象是否经历过一次`Scavenge`算法
- `To`空间的内存占比是否已经超过`25%`

默认情况下，我们创建的对象都会分配在`From`空间中，当进行垃圾回收时，在将对象从`From`空间复制到`To`空间之前，会先检查该对象的内存地址来判断是否已经经历过一次`Scavenge`算法，如果地址已经发生变动则会将该对象转移到老生代中，不会再被复制到`To`空间。如果对象没有经历过`Scavenge`算法，会被复制到`To`空间，但是如果此时`To`空间的内存占比已经超过`25%`，则该对象依旧会被转移到老生代。

可以用以下的流程图来表示：

![](https://gitee.com/gainmore/imglib/raw/master/img/upgrade.png)

之所以有`25%`的内存限制是因为`To`空间在经历过一次`Scavenge`算法后会和`From`空间完成角色互换，会变为`From`空间，后续的内存分配都是在`From`空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理。

---

##### 老生代

在老生代中，因为管理着大量的存活对象，如果依旧使用`Scavenge`算法的话，很明显会浪费一半的内存，因此已经不再使用`Scavenge`算法，而是采用新的算法`Mark-Sweep(标记清除)`和`Mark-Compact(标记整理)`来进行管理。

`Mark-Sweep(标记清除)`分为`标记`和`清除`两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。`Mark-Sweep`算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：

- 垃圾回收器会在内部构建一个`根列表`，用于存放所有根节点，从根节点出发去寻找那些可以被访问到的变量。比如在JavaScript中，`window`全局对象可以看成一个根节点。

  > 以下几种情况都可以作为根节点：
  >
  > 1. 全局对象
  > 2. 本地函数的局部变量和参数
  > 3. 当前嵌套调用链上的其他函数的变量和参数

- 然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。

- 最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。

但是`Mark-Sweep`算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面**如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收**，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。

为了解决这种内存碎片的问题，`Mark-Compact(标记整理)`算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存。

---

### 总结

V8 引擎采用的是分代式垃圾回收。在堆内存中分为新生代空间和老生代空间，新生代采用的是 `Scavenge算法`，而老生代早先采用的是`引用计数`，后来采用了`标记清除`，之后又改进为`标记整理`。

Scavenge 算法主要是在进行垃圾回收时，给新生代中的 From 空间里的不活动对象打上标记，然后将活动对象复制到 To 空间里，之后再清除 From 空间的所有对象，将 From 空间和 To 空间进行交换，如此往复。

当对象进行了一次 Scavenge 算法或者 To 空间里的内存大于 25% 时，就会将对象转移到老生代空间中，这个过程称为对象晋升。

老生代一开始采用的引用计数方法，指的是创建一个对象，如果该对象被一个变量引用，那么这个对象的引用次数 +1，失去一个变量的引用，那么引用次数 -1，当引用次数变为 0 时，这个对象就成了垃圾对象，被 GC 回收。

由于这个方法存在循环引用问题，所以后来采用了标记清除算法。标记清除算法分为 `标记` 和 `清除` 两个阶段，在标记阶段，垃圾回收器会从所有根节点出发，遍历所有可以访问到的节点，将可以访问到的节点标记为活动对象，不能访问到的则标记为不活动，视为垃圾对象。在清除阶段，垃圾回收器会释放所有垃圾对象的内存。

而由于标记清除算法会造成剩余空间不连续，容易产生内存碎片，所以提出了标记整理算法，这个算法在标记阶段和标记清除算法相同，只是在标记结束后，会把所有活动对象移到内存的一端上，使剩余内存变成一段连续的空间。

---

### 参考资料

- https://juejin.cn/post/6844904016325902344
- https://juejin.cn/post/6981588276356317214
- https://www.bilibili.com/video/BV18M4y1u78g

